# [139. Word Break](https://leetcode.com/problems/word-break/)

## Solution 1 Regular DP, 11ms, 56.3%
TC: O(n^3), SC: O(n+k) where n is length of S and k is number of words in wordDict
```java
class Solution {
    public boolean wordBreak(String s, List<String> wordDict) {
        Set<String> set = new HashSet<>(wordDict);
        int n = s.length();
        boolean[] dp = new boolean[n + 1];
        dp[0] = true; // base case: ""
        for (int i = 1; i <= n; i++) {
          for (int j = 0; j < i; j++) {
            if (dp[j] && set.contains(s.substring(j, i))) {
              dp[i] = true;      // solve dp[i], break to next 
              break;
            }
          }
        }
        return dp[n];
    }
}
```
## Solution 1b, optimized upon previous DP, 4ms, 88.18%
Optimization:
1. for word length greater than s, no need to put it into word set
2. remember all length of each word in set, we only substring (and try to match in set) the right len
```java
class Solution {
    public boolean wordBreak(String s, List<String> wordDict) {
        Set<String> set = new HashSet<>();
        Set<Integer> lenSet = new HashSet<>();
        int n = s.length(), minLen = minLen(set, lenSet, wordDict, n);
        boolean[] dp = new boolean[n+1];
        dp[0] = true;
        for (int i = 1; i <= n; i++) for (int j = 0; j < i-minLen+1; j++) {
            if (dp[j] && lenSet.contains(i-j) && set.contains(s.substring(j, i))) {
                dp[i] = true;
                break;
            }
        }
        return dp[n];
    }
    
    private int minLen(Set<String> set, Set<Integer> lenSet, List<String> wordDict, int n) {
        int res = Integer.MAX_VALUE;
        for (String w : wordDict) {
            if (w.length() < res) res = w.length();
            if (w.length() <= n) {
                set.add(w);
                lenSet.add(w.length());
            }
        }
        
        return res;
    }
}
```
## Solution 1c, further optimization, 2ms, 98.12%
Optimization:
1. sort all unique length in wordDict by ascending order 
2. iterate over len only, when length is more than sub-problem length, no need to check further
```java
class Solution {
    public boolean wordBreak(String s, List<String> wordDict) {
        // prep unique and ascending word len array
        Set<String> set = new HashSet<>();
        int n = s.length();
        int[] lens = prep(set, wordDict, n);

        // start dp
        boolean[] dp = new boolean[n+1];
        dp[0] = true; int j;
        for (int i = 1; i <= n; i++) for (int x : lens) {
            if ((j = i - x) < 0) break;
            if (dp[j] && set.contains(s.substring(j, i))) {
                dp[i] = true;
                break;
            }
        }
        return dp[n];
    }

    private int[] prep(Set<String> set, List<String> wordDict, int n) {
        Set<Integer> lenSet = new HashSet<>();
        for (String w : wordDict)
            if (w.length() <= n) {
                set.add(w);
                lenSet.add(w.length());
            }

        // convert lenSet to int[] and sort it for speed and early termination
        int[] lens = new int[lenSet.size()]; int k = 0;
        for (int x : lenSet) lens[k++] = x;
        Arrays.sort(lens);
        return lens;
    }
}
```