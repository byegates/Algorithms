# [97. Interleaving String](https://leetcode.com/problems/interleaving-string/)

## 2d DP, 2ms, 85.02%
TC/SC: O(m*n) (m, n are s1, s2 length respectively)
```java
class Solution {
    public boolean isInterleave(String s1, String s2, String s3) {
        int n1 = s1.length(), n2 = s2.length(), n3 = s3.length();
        if (n1 + n2 != n3) return false;
        char[] a1 = s1.toCharArray(), a2 = s2.toCharArray(), a3 = s3.toCharArray();

        boolean[][] dp = new boolean[n1+1][n2+1]; // dp[i+1][j+1] can s1[0,i] and s2[0,j] combines to s3[0,i+j+1];
        dp[0][0] = true; // "" + "" = ""
        for (int i = 0; i < n1; i++) dp[i+1][0] = dp[i][0] && a1[i] == a3[i];
        for (int j = 0; j < n2; j++) dp[0][j+1] = dp[0][j] && a2[j] == a3[j];

        for (int i = 0; i < n1; i++) for (int j = 0; j < n2; j++)
            dp[i+1][j+1] = dp[i][j+1] && a1[i] == a3[i+j+1] || dp[i+1][j] && a2[j] == a3[i+j+1];

        return dp[n1][n2];
    }
}
```

## Optimize space to 1D
TC: O(m*n), SC: O(min(m, n)) (If we add logic to check which one is smaller and use that one for dp)

因为填表的时候只回看左边和上面，对角线都不看，1d基本不需要额外逻辑
```java
class Solution {
    public boolean isInterleave(String s1, String s2, String s3) {
        int n1 = s1.length(), n2 = s2.length(), n3 = s3.length();
        if (n1 + n2 != n3) return false;
        char[] a1 = s1.toCharArray(), a2 = s2.toCharArray(), a3 = s3.toCharArray();
        
        boolean[] dp = new boolean[n2+1]; // dp[i+1][j+1] can s1[0,i] and s2[0,j] combines to s3[0,i+j+1];
        dp[0] = true; // "" + "" = ""
        for (int j = 0; j < n2; j++) dp[j+1] = dp[j] && a2[j] == a3[j];
        
        for (int i = 0; i < n1; i++) {
            dp[0] = dp[0] && a1[i] == a3[i];
            for (int j = 0; j < n2; j++)
                dp[j+1] = dp[j+1] && a1[i] == a3[i+j+1] || dp[j] && a2[j] == a3[i+j+1];
        }
        
        return dp[n2];
    }
}
```