# [121. Best Time to Buy and Sell Stock](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/)

## Greedy? Better?
TC: O(n), SC: O(1)
```java
class Solution {
    public int maxProfit(int[] p) {
        int min = p[0], res = 0;
        for (int x : p)
            if (x <= min) min = x;
            else res = Math.max(res, x - min);;
        return res;
    }
}
```
## state machine
TC: O(n), SC: O(1)
s0: 买了没卖的状态，s1: 买了0或者1次又卖了的状态
```java
class Solution {
    public int maxProfit(int[] p) {
        int s0 = Integer.MIN_VALUE, s1 = 0;
        for (int x : p) {
            s0 = Math.max(s0,    - x);
            s1 = Math.max(s1, s0 + x);
        }
        return s1;
    }
}
```
# [123. Best Time to Buy and Sell Stock III](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/)
## state machine, 2ms, 99.96%
[Link to State Machine on this problem](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/discuss/149383/Easy-DP-solution-using-state-machine-O(n)-time-complexity-O(1)-space-complexity)
TC: O(n), SC: O(1)
```java
class Solution {
    public int maxProfit(int[] p) {
        int s0, s1 = 0, s2, s3 = 0, n = p.length;
        s0 = s2 = Integer.MIN_VALUE;

        for (int x : p) {
            s0 = Math.max(s0,    - x);
            s1 = Math.max(s1, s0 + x);
            s2 = Math.max(s2, s1 - x);
            s3 = Math.max(s3, s2 + x);
        }

        return s3;
    }
}
```

# [188. Best Time to Buy and Sell Stock IV](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/)
## State Machine, 1ms, 100%
```java
class Solution {
    public int maxProfit(int k, int[] p) {
        int n = p.length;
        if (k >= n / 2) return maxProfit2(p);

        int[] s = new int[2 * k + 1];
        for (int i = 1; i < 2 * k; i += 2) s[i] = Integer.MIN_VALUE;

        for (int x : p) for (int i = 1; i <= 2*k; i+=2) {
            s[i]   = Math.max(s[i], s[i-1] - x);
            s[i+1] = Math.max(s[i+1], s[i] + x);
        }

        return s[2*k];
    }


    public int maxProfit2(int[] p) {
        int res = 0;
        for (int i = 1; i < p.length; i++)
            if (p[i] > p [i-1]) res += p[i] - p[i-1];
        return res;
    }
}

/*
You could write the loop in the middle this way:
        int[] sign = new int[] {1, -1};
        for (int x : p) for (int i = 1; i <= 2*k; i++)
            s[i] = Math.max(s[i], s[i-1] + sign[i%2] * x);
 */
```
## DP
```java
class Solution {
    public int maxProfit(int k, int[] p) {
        int n = p.length;
        if ( n == 0 || k == 0) return 0;
        if (k >= n/2) return maxProfit2(p);

        int[][] dp = new int[k + 1][n]; // k transactions, n prices
        for (int i = 1; i <= k; i++) { // i-th transaction
            int balance = -p[0]; // s0?
            for (int j = 1; j < n; j++) { // j-th price
                dp[i][j] = Math.max(dp[i][j-1],   balance + p[j]); // sell it yesterday or today
                balance  = Math.max(balance, dp[i-1][j-1] - p[j]); // buy it today or yesterday (1 transaction away)
            }
        }
        return dp[k][n - 1];
    }

    public int maxProfit2(int[] p) {
        int res = 0;
        for (int i = 1; i < p.length; i++)
            if (p[i] > p [i-1]) res += p[i] - p[i-1];
        return res;
    }
}
```
# [122. Best Time to Buy and Sell Stock II](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/)
## TC: O(n), SC: O(1)
```java
class Solution {
    public int maxProfit(int[] p) {
        int res = 0;
        for (int i = 1; i < p.length; i++)
            if (p[i] > p [i-1]) res += p[i] - p[i-1];
        return res;
    }
}
```