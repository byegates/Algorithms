# [2478. Number of Beautiful Partitions](https://leetcode.com/problems/number-of-beautiful-partitions/)
## 
## dfs + memo, 292 ms, 14.29%
<pre>
TC: O(k*n)
SC: O(k+n)
n: unique number of valid cuts
</pre>
```java
class Solution {
    public int beautifulPartitions(String s, int k, int minL) {
        int n = s.length();
        if (minL*k > n) return 0; // corner case 1: total length is not enough

        boolean[] isP = new boolean[10];
        isP[2] = isP[3] = isP[5] = isP[7] = true;

        if (!isP[s.charAt(0)-'0'] || isP[s.charAt(n-1)-'0']) return 0; // corner case 2: beginning or end is not valid

        List<Integer> cuts = new ArrayList<>();
        cuts.add(0); // first beginning index
        for (int i = minL; i < n; i++) if (isP[s.charAt(i)-'0'] && !isP[s.charAt(i-1)-'0']) cuts.add(i); // each possible beginning index

        if (cuts.size() < k-1) return 0; // corner case 3

        int[][] dp = new int[k+1][cuts.size()];
        for (var _a : dp) Arrays.fill(_a, -1); // -1 means not visited

        // for (int i = 0; i < k; i++) System.out.println(Arrays.toString(dp[i]));
        return dfs(cuts, k, 0, n, minL, dp);
    }

    private int dfs(List<Integer> cuts, int k, int cur, int n, int len, int[][] dp) {
        if (k == 1) return dp[k][cur] = cuts.get(cur) + len <= n ? 1 : 0; // enough length for last segment
        if (dp[k][cur] > -1) return dp[k][cur];

        dp[k][cur] = 0;
        for (int i = cur+1; i < cuts.size()-k+2; i++) { // 
            if (cuts.get(i) - cuts.get(cur) < len) continue;
            dp[k][cur] = (dp[k][cur] + dfs(cuts, k-1, i, n, len, dp)) % 1_000_000_007;
        }

        return dp[k][cur];
    }
}
```