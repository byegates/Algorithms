# [2478. Number of Beautiful Partitions](https://leetcode.com/problems/number-of-beautiful-partitions/)
[Detail](https://leetcode.com/problems/number-of-beautiful-partitions/discuss/2834170/JavaorDFS%2BMEMOorEasy-to-understand)
## dfs + memo, 292 ms, 14.29%
<pre>
TC: O(k*n)
SC: O(k+n)
n: unique number of valid cuts
</pre>
```java
class Solution {
    public int beautifulPartitions(String s, int k, int minL) {
        int n = s.length();
        if (minL*k > n) return 0; // corner case 1: total length is not enough

        boolean[] P = new boolean[10];
        P[2] = P[3] = P[5] = P[7] = true;

        if (!P[s.charAt(0)-'0'] || P[s.charAt(n-1)-'0']) return 0; // corner case 2: beginning or end is not valid

        List<Integer> cuts = new ArrayList<>();
        cuts.add(0); // first beginning index
        for (int i = minL; i < n; i++) if (P[s.charAt(i)-'0'] && !P[s.charAt(i-1)-'0']) cuts.add(i); // each possible beginning index

        if (cuts.size() < k-1) return 0; // corner case 3

        int[][] dp = new int[k+1][cuts.size()];
        for (var _a : dp) Arrays.fill(_a, -1); // -1 means not visited

        // for (int i = 0; i < k; i++) System.out.println(Arrays.toString(dp[i]));
        return dfs(cuts, k, 0, n, minL, dp);
    }

    private int dfs(List<Integer> cuts, int k, int cur, int n, int len, int[][] dp) {
        if (k == 1) return dp[k][cur] = cuts.get(cur) + len <= n ? 1 : 0; // enough length for last segment
        if (dp[k][cur] > -1) return dp[k][cur];

        dp[k][cur] = 0;
        for (int i = cur+1; i < cuts.size()-k+2; i++) { // 
            if (cuts.get(i) - cuts.get(cur) < len) continue;
            dp[k][cur] = (dp[k][cur] + dfs(cuts, k-1, i, n, len, dp)) % 1_000_000_007;
        }

        return dp[k][cur];
    }
}
```
## DP, 19ms 100%
```java
class Solution {
    private static boolean[] P = new boolean[10];
    private static int M = 1_000_000_007;
    public int beautifulPartitions(String s, int k, int minL) {
        int n = s.length();
        P[2] = P[3] = P[5] = P[7] = true;
        if (!P[s.charAt(0)-'0'] || P[s.charAt(n-1)-'0']) return 0; // corner case

        boolean[] a = new boolean[n];
        a[n-1] = true;
        for (int i = minL-1; i < n-2; i++) // find all good ending index for partition
            a[i] = !P[s.charAt(i)-'0'] && P[s.charAt(i+1)-'0'];

        return beautifulPartitions(a, k, minL, n); // actual DP, above are prep work
    }

    private int beautifulPartitions(boolean[] a, int k, int minL, int n) {
        // dp[i][j]: answer to substring:[0, j] into i partitions
        int[][] dp = new int[k+1][n];

        for (int j = minL-1; j < n; j++) dp[1][j] = a[j] ? 1 : 0; // just 1 partition
        for (int i = 2; i <= k; i++) { // making 2 to k partitions
            int cur = 0;
            for (int j = minL*i-1; j < n; j++) { // for i partitions, len is at least minL * i
                int pre = j-minL;
                if (a[pre]) cur = (cur + dp[i-1][pre]) % M; // a good previous end
                if (a[j]) dp[i][j] = (dp[i][j] + cur) % M; // a ending point
            }
        }

        return dp[k][n-1]; // string[0,n] divided into k partitions
    }
}

```
## Optimized dp, 16ms
```java
class Solution {
    private static boolean[] P = new boolean[10];
    private static int M = 1_000_000_007;
    public int beautifulPartitions(String s, int k, int minL) {
        int n = s.length();
        P[2] = P[3] = P[5] = P[7] = true;
        if (!P[s.charAt(0)-'0'] || P[s.charAt(n-1)-'0']) return 0; // early termination

        return beautifulPartitions(getPre(s, n, minL), k, minL); // actual DP, above are prep work
    }

    private int beautifulPartitions(int[] pre, int k, int minL) {
        int n = pre.length;
        int[][] dp = new int[k][n]; 

        for (int j = 1; j < n; j++) dp[0][j] = 1; // making 1 partition
        for (int i = 1; i < k; i++) { // making 2 to k partitions
            int[] psum = new int[n];
            for (int j = i; j < n; j++) { // for i partitions, len is at least minL * i
                psum[j] = (psum[j-1] + dp[i-1][j]) % M; // a good previous end
                dp[i][j] = (dp[i][j] + psum[pre[j]]) % M; // a ending point
            }
        }
        return dp[k-1][n-1]; // string[0,n] divided into k partitions
    }

    private int[] getPre(String s, int n, int minL) { // valid indices for partition
        List<Integer> cuts = new ArrayList<>(n/2+1);
        for (int i = minL-1; i < n-2; i++) // find all good ending index for partition
            if (!P[s.charAt(i)-'0'] && P[s.charAt(i+1)-'0']) cuts.add(i);

        int m = cuts.size()+2;
        int[] a = new int[m]; // optional conversion of list to array for speed
        a[1] = -1;a[m-1]=n-1; // -2 and -1 are useful dummies, n-1 is the last good ending index
        for (int i = 0; i < cuts.size(); i++) a[i+1] = cuts.get(i);

        int[] pre = new int[m]; // largest pre idx for cur end to make a valid partition
        for (int i = 1; i < m; i++) pre[i] = bs(a, a[i]-minL);

        return pre;
    }

    private int bs(int[] a, int x) { // find the largest <=
        int l = 0, r = a.length;
        while (l < r) {
            int m = r- (r-l) / 2;
            if (a[m] == x) return m;
            else if (a[m] > x) r = m-1;
            else l = m;
        }
        return r;
    }
}
```