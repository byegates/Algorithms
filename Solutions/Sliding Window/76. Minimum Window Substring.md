# [76. Minimum Window Substring](https://leetcode.com/problems/minimum-window-substring/)

[LaiCode 156. Minimum Window Substring](https://app.laicode.io/app/problem/156)

[293. Smallest Substring Containing All Characters Of Another String](https://app.laicode.io/app/problem/293)
Exact same problem as LaiCode 156/LeetCode 76, only difference is name of the method: (smallest vs minWindow);

## Solution 1 using map
TC: O(n + m) where n = s.length() and m = t.length()

SC: O(unique(m)), size of map
```java
class Solution {
    public String minWindow(String s, String t) {
        if (t.equals("") || t.length() > s.length()) return "";
        Map<Character, Integer> map = new HashMap<>();
        for (char c : t.toCharArray()) map.put(c, map.getOrDefault(c, 0) + 1);

        int min = Integer.MAX_VALUE, start = 0;

        int toMatch = map.size();
        for (int i = 0, j = 0; j < s.length(); j++) {
            char c = s.charAt(j);
            Integer count = map.get(c);
            if (count == null) continue;
            map.put(c, --count);
            if (count == 0) toMatch--;

            for (; (count = map.get(c = s.charAt(i))) == null || count < 0; i++)
                if (count != null) map.put(c, ++count);

            int len = j - i + 1;
            if (toMatch == 0 && (len < min)) {
                min = len;
                start = i;
            }
        }

        return min == Integer.MAX_VALUE ? "" : s.substring(start, start + min);
    }
}
```

## Solution 2, array instead of map, which would run faster
as the String only have upper and lower case chars, so we can use 'z' - 'A' + 1 as its length;

Complexity is the same as previous Solution 1
```java
class Solution {
    public String minWindow(String s, String t) {
        if (t.equals("") || t.length() > s.length()) return "";
        Integer[] map = new Integer['z' - 'A' + 1]; // 'A' = 65, 'z' = 122; size of this map will be 58
        int toMatch = 0, len, idx;
        for (int i = 0; i < t.length(); i++)
            if (map[idx = t.charAt(i) - 'A'] == null) {
                map[idx] = 1;
                toMatch++;
            } else map[idx]++;

        int start = 0, min = Integer.MAX_VALUE;

        for (int i = 0, j = 0; j < s.length(); j++) { // i: slow pointer, j: fast pointer
            if (map[idx = s.charAt(j) - 'A'] == null) continue; // don't care about non-related chars

            if (--map[idx] == 0) toMatch--; // take in new chars
            for (; map[idx = s.charAt(i) - 'A'] == null || map[idx] < 0; i++) // remove old chars
                if (map[idx] != null) map[idx]++;

            if (toMatch == 0 && (len = j - i + 1) < min) {
                start = i;
                min = len;
            }
        }
        return min == Integer.MAX_VALUE ? "" : s.substring(start, start + min);
    }
}
```