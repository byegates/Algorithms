# [76. Minimum Window Substring](https://leetcode.com/problems/minimum-window-substring/)

[LaiCode 156. Minimum Window Substring](https://app.laicode.io/app/problem/156)

[293. Smallest Substring Containing All Characters Of Another String](https://app.laicode.io/app/problem/293)
Exact same problem as LaiCode 156/LeetCode 76, only difference is name of the method: (smallest vs minWindow);

### 思路
1. 建立一个target String的所有字符的count map
   1. 记录总共需要match的字符的个数(也就是map的size, 也就是target String中unique字符的个数), 可以命名为toMatch
2. one Pass 撸一遍 source String, 每一轮吃一个char
   1. 每吃一个char, 如果不在count map里面(取出来的count == null), 忽略
      1. 如果在count map里面那么count减一(物理意义是需要match的count少了一个)
         1. 每次count减少1, 都检查一下，如果字符对应的count减少到0了，总需要match的字符数(toMatch)就减1。
   2. 每次吃完一个新的字符，同时检查sliding window的尾部(此处用指针i表示)可不可以吐:
      1. 如果是不在target中的字符(map中拿出来的count为null)，随便不停的的吐
      2. 是在target中, 则要看需要match的数量是不是 < 0, 如果是，说明吃进去了more than enough的此字符，那也可以吐
         1. 每吐掉一个吃多了的字符，对应count应该增加1个，到0终止此次吐循环
   3. 总需要match字符数(toMatch)如果减少到0，说明找到一个target的完整match, 更新长度和起点到全剧结果(如果够短)
## Solution 1 using map
TC: O(n + m) where n = s.length() and m = t.length()

SC: O(unique(m)), size of map
```java
class Solution {
    public String minWindow(String s, String t) {
        if (t.equals("") || t.length() > s.length()) return "";
        Map<Character, Integer> map = new HashMap<>();
        for (char c : t.toCharArray()) map.put(c, map.getOrDefault(c, 0) + 1);

        int min = Integer.MAX_VALUE, start = 0;

        int toMatch = map.size();
        for (int i = 0, j = 0; j < s.length(); j++) {
            char c = s.charAt(j);
            Integer count = map.get(c);
            if (count == null) continue;
            map.put(c, --count);
            if (count == 0) toMatch--;

            for (; (count = map.get(c = s.charAt(i))) == null || count < 0; i++)
                if (count != null) map.put(c, ++count);

            int len = j - i + 1;
            if (toMatch == 0 && (len < min)) {
                min = len;
                start = i;
            }
        }

        return min == Integer.MAX_VALUE ? "" : s.substring(start, start + min);
    }
}
```

## Solution 2, array instead of map, which would run faster
as the String only have upper and lower case chars, so we can use 'z' - 'A' + 1 as its length;

Complexity is the same as previous Solution 1
```java
class Solution {
    public String minWindow(String s, String t) {
        if (t.equals("") || t.length() > s.length()) return "";
        Integer[] map = new Integer['z' - 'A' + 1]; // 'A' = 65, 'z' = 122; size of this map will be 58
        int toMatch = 0, len, idx;
        for (int i = 0; i < t.length(); i++)
            if (map[idx = t.charAt(i) - 'A'] == null) {
                map[idx] = 1;
                toMatch++;
            } else map[idx]++;

        int start = 0, min = Integer.MAX_VALUE;

        for (int i = 0, j = 0; j < s.length(); j++) { // i: slow pointer, j: fast pointer
            if (map[idx = s.charAt(j) - 'A'] == null) continue; // don't care about non-related chars

            if (--map[idx] == 0) toMatch--; // take in new chars
            for (; map[idx = s.charAt(i) - 'A'] == null || map[idx] < 0; i++) // remove old chars
                if (map[idx] != null) map[idx]++;

            if (toMatch == 0 && (len = j - i + 1) < min) {
                start = i;
                min = len;
            }
        }
        return min == Integer.MAX_VALUE ? "" : s.substring(start, start + min);
    }
}
```