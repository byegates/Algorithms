# [403. Frog Jump](https://leetcode.com/problems/frog-jump/)

## Solution 0, 2d DP
```java
class Solution {
    public boolean canCross(int[] a) {
        int n = a.length;
        // dp[i][j]: èƒ½ä¸èƒ½ä»å¤´ç»è¿‡ä¸€æ¬¡sizeä¸ºjçš„è·³é±¼åˆ°è¾¾ä½ç½®a[i]
        // é‡ç‚¹, è·³åˆ°index1ï¼Œæœ€å¤§jump sizeæ˜¯1ï¼Œæ¯ä¸€æ­¥å¢åŠ 1ï¼Œè·³åˆ°indexi,æœ€å¤§jump sizeå°±æ˜¯i
        // æ‰€ä»¥æ•´ä¸ªarrayé‡Œå¯èƒ½çš„æœ€å¤§jump sizeå°±æ˜¯length - 1
        // dp[i][j] çš„ç¬¬äºŒç»´ åªéœ€è¦n
        boolean[][] dp = new boolean[n][n];
        dp[0][1] = true; // ä»ä½ç½®0ï¼Œå¯ä»¥è·³size 1
        for(int i = 1; i < n; i++){ // ç¬¬ä¸€å±‚å¾ªç¯åˆ¤æ–­èƒ½ä¸èƒ½è·³åˆ°i
            for(int j = 0; j < i; j++){ // ç¬¬äºŒå±‚çœ‹ä»jèƒ½ä¸èƒ½è·³åˆ°i
                int diff = a[i] - a[j]; // ä»jè·³åˆ°iéœ€è¦çš„size
                // sizeå¦‚æœè¶…è¿‡nï¼Œ(æ•´ä¸ªarrayçš„æœ€å¤§stepåªæœ‰n-1)ï¼Œä»»ä½•ä¸¤ä¸ªç‚¹ä¹‹é—´éœ€è¦næ­¥or more å°±ä¸ç”¨çœ‹äº†
                // æˆ–è€…ä»jè·³ä¸äº†diffæ­¥(é‚£ä¹ˆä»jå°±åˆ°ä¸äº†i)ï¼Œç»§ç»­
                if(diff >= n || !dp[j][diff]) continue;

                dp[i][diff] = true; // å¯ä»¥ä»å¤´ç»è¿‡jå†è·³ä¸€ä¸ªdiff sizeçš„æ­¥åˆ°i
                if(i == n - 1) return true; // early term ä¸€ä¸‹
                if(diff - 1 >= 0) dp[i][diff - 1] = true; // diff -1 æ­¥å¯ä»¥è·³åˆ°j
                if(diff + 1 <= n) dp[i][diff + 1] = true; // diff +1 æ­¥å¯ä»¥è·³åˆ°j
            }
        }
        return false;
    }    
}
```

## Solution 1 DP with map of set, bottom up
```java
class Solution {
    public boolean canCross(int[] a) {
        // map: starting at k, all available jump sizes
        Map<Integer, Set<Integer>> map = new HashMap<>();
        // setç”¨æ¥å­˜ä¸åŒçš„å¯ä»¥è·³åˆ°å½“å‰ä½ç½®çš„size
        for (int x : a) map.put(x, new HashSet<>());

        int n = a.length;
        // we pretend we jumped 0 size to position 0
        // this is to control next step from 0 can only be 1
        // NOTE: array[0] is always 0
        map.get(0).add(0);

        for (int cur : a) { // iterate over all possible 
            for (int x : map.get(cur)) { // çœ‹çœ‹å¤šå°‘sizeè·³è¿‡æ¥çš„, å†³å®šä¸‹ä¸€ä¸ªsize
                for (int size = x - 1; size <= x + 1; size++) { // ä¸‹ä¸€æ­¥çš„size
                    if (size <= 0) continue; // of course
                    Set<Integer> set = map.get(cur + size);
                    if (set == null) continue; // ä¸‹ä¸€æ­¥ä¸åˆæ³•
                    set.add(size); // ä¸‹ä¸€æ­¥åˆæ³•ï¼Œé‚£è®°ä¸€ä¸‹åˆ°ä¸‹ä¸€æ­¥çš„size
                }
            }
        }

        return map.get(a[n - 1]).size() > 0; // è‡³å°‘ä¸€ä¸ªé€‰æ‹©å¯ä»¥è·³åˆ°æœ€åä¸€ä¸ªä½ç½®
    }
}
```

## Solution 2, recursion with memo
```java
class Solution {
    public boolean canCross(int[] a) {
        int n = a.length;
        Map<Integer, Integer> map = new HashMap<>();
        for (int i = 0; i < n; i++) map.put(a[i], i);
        Boolean[][] dp = new Boolean[n][n]; // ä½ ä¸ªä½ç½®ï¼Œæœ€å¤§å¯èƒ½çš„sizeæ˜¯n-1ï¼Œ0 ~ n - 1ä¹Ÿæ˜¯nä¸ªä¸åŒçš„ jump size
        return dfs(a, 0, 0, dp, map); // ä»0 å¼€å§‹ï¼Œä¸Šä¸€æ­¥è·³äº†size 0 (åˆå§‹çŠ¶æ€) èƒ½ä¸èƒ½åˆ°è¾¾ç»ˆç‚¹ğŸï¼Ÿ
    }
    
    private boolean dfs(int[] a, int idx, int jump, Boolean[][] dp, Map<Integer, Integer> map) {
        if (idx == a.length - 1) return true; // åˆ°äº†!
        if (dp[idx][jump] != null) return dp[idx][jump]; // return your memo, good or bad
        
        for (int i = jump - 1; i <= jump + 1; i++) { // i is next jump sizes
            if (i <= 0) continue;
            Integer pos = map.get(a[idx] + i); // è¿™ä¸€è·³èƒ½ä¸èƒ½åˆ°è¾¾ä¸€ä¸ªæœ‰æ•ˆä½ç½®?
            if (pos == null) continue; // è·³åˆ°æ— æ•ˆä½ç½®ï¼Œ886
            if (dfs(a, pos, i, dp, map)) // è·³åˆ°æœ‰æ•ˆä½ç½®ï¼Œé—®é—®recursionèƒ½ä¸èƒ½æå®šå–½
                return dp[pos][jump] = true;
        }
        
        return dp[idx][jump] = false; // éƒ½åˆ°è¿™å„¿äº†ï¼Œé‚£å°±æ˜¯æ²¡æå®šå•Š
    }
}
```
