# Different Ways to Add Parentheses
[LeetCode 241. Different Ways to Add Parentheses](https://leetcode.com/problems/different-ways-to-add-parentheses/submissions/)

[475. Different Ways to Add Parentheses](https://app.laicode.io/app/problem/475)

## Recursion
Time complexity : The main computations are to construct all possible trees with a given root, that is actually Catalan number Gn
as was discussed above. This is done n times, that results in time complexity n *Gn. Catalan numbers grow as 4^n/n^(3/2), that gives the final complexity
O(4^n/n^(1/2)).

SC: O(number of operands)

[Catalan number](https://en.wikipedia.org/wiki/Catalan_number)
```java
class Solution {
    public List<Integer> diffWaysToCompute(String s) {
        if (Objects.equals(s, "")) return new ArrayList<>();
        List<Integer> nums = new ArrayList<>(); // list of all numbers from input
        List<Character> ops = new ArrayList<>(); // list of all operands from input
        parseInput(s, nums, ops);
        int n = nums.size();
        List<Integer>[][] dp = new ArrayList[n][n];
        dfs(0, n - 1, dp, nums, ops);
        // Collections.sort(dp[0][n-1]); // LaiCode need this before return
        return dp[0][n - 1];
    }
    
    private void parseInput(String s, List<Integer> nums, List<Character> ops) {
        int start = 0;
        for (int i = 1; i < s.length(); i++) {
            char c = s.charAt(i);
            if (c == '*' || c == '+' || c == '-') {
                ops.add(c);
                nums.add(Integer.parseInt(s.substring(start, i))); // parse numbers
                start = i + 1;
            }
        }
        nums.add(Integer.parseInt(s.substring(start))); // add the last number
    }

    private void dfs(int l, int r, List<Integer>[][] dp, List<Integer> nums, List<Character> ops) {
        if (dp[l][r] != null) return;
        ArrayList<Integer> list = new ArrayList<>();
        if (l == r) {
            list.add(nums.get(l));
            dp[l][r] = list;
            return;
        }

        for (int cut = l; cut < r; cut++) {
            dfs(l, cut, dp, nums, ops);
            dfs(cut + 1, r, dp, nums, ops);
            for (int x : dp[l][cut])
                for (int y : dp[cut + 1][r])
                    switch (ops.get(cut)) {
                        case '*' -> list.add(x * y);
                        case '+' -> list.add(x + y);
                        case '-' -> list.add(x - y);
                    }
        }
        dp[l][r] = list;
    }
}
// LaiCode do not support above lambda expression, use below
//                    switch (ops.get(cut)) {
//                        case '*': list.add(x * y); break;
//                        case '+': list.add(x + y); break;
//                        case '-': list.add(x - y); break;
//                    }
```
