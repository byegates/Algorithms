# [1293. Shortest Path in a Grid with Obstacles Elimination](https://leetcode.com/problems/shortest-path-in-a-grid-with-obstacles-elimination/)

## Solution 0, BFS with de-dup on k (8ms, 93.71%, 41.7 MB, less than 98.66%)
<pre>
TC: O(m*n*k), all Nodes, All edges will be 4 * all nodes, still same order of magnitude
SC: O(m*n*k)
</pre>
```java
class Solution {
    private static final int[][] DIRS = new int[][] { {0, 1}, {0, -1}, {1, 0}, {-1, 0} };
    record Cell (int i, int j, int steps, int k) {}

    public int shortestPath(int[][] grid, int k) {
        int rows = grid.length, cols = grid[0].length, max = rows + cols - 2;
        if (k >= max - 1) return max; // if you add this line, it will eliminate most of the test cases... and you can get it done within 2 ms
        int[][] visited = new int[rows][cols];
        Queue<Cell> q = new ArrayDeque<>();

        for (int[] row : visited) Arrays.fill(row, -1);
        q.offer(new Cell(0, 0, 0, k));
        visited[0][0] = k;


        while (!q.isEmpty()) {
            Cell cur = q.poll();
            if (cur.i == rows - 1 && cur.j == cols - 1) return cur.steps;
            for (var dir : DIRS) {
                int i = cur.i + dir[0], j = cur.j + dir[1], nextK;
                if (i < 0 || j < 0 || i >= rows || j >= cols) continue;
                if ((nextK = cur.k - grid[i][j])  <= visited[i][j]) continue;
                q.offer(new Cell(i, j, cur.steps + 1, nextK));
                visited[i][j] = nextK;
            }
        }

        return -1;
    }
}
```
## Solution 0b, A* (3ms, 99.57%, 41.4 MB, 99.94%)
<pre>
Number of edges are at max 4 * number of nodes, only same order of magnitude
TC: O(m*n*k*log(m*n*k))
SC: O(m*n*k)
</pre>
```java
class Solution {
    private static final int[][] DIRS = new int[][] { {0, 1}, {0, -1}, {1, 0}, {-1, 0} };
    record Cell (int i, int j, int steps, int k, int est) {}

    public int shortestPath(int[][] grid, int k) {
        int rows = grid.length, cols = grid[0].length, max = rows + cols - 2;
        if (k >= max - 1) return max; // if you add this line, it will eliminate most of the test cases...
        int[][] visited = new int[rows][cols];
        // est is all steps used so far + manhattan distance for rest of the steps
        PriorityQueue<Cell> q = new PriorityQueue<>((a, b) -> (a.est - b.est));

        for (int[] row : visited) Arrays.fill(row, -1);
        q.offer(new Cell(0, 0, 0, k, max));
        visited[0][0] = k;

        while (!q.isEmpty()) {
            Cell cur = q.poll();
            if (cur.est - cur.steps <= cur.k) return cur.est;
            if (cur.i == rows - 1 && cur.j == cols - 1) return cur.steps;
            for (var dir : DIRS) {
                int i = cur.i + dir[0], j = cur.j + dir[1], nextK;
                if (i < 0 || j < 0 || i >= rows || j >= cols) continue;
                if ((nextK = cur.k - grid[i][j])  <= visited[i][j]) continue;
                q.offer(new Cell(i, j, cur.steps + 1, nextK, max - i - j + cur.steps + 1));
                visited[i][j] = nextK;
            }
        }

        return -1;
    }
}
```
### Solution 1 simpler 3d de-dup boolean (30ms)
Time: O(M * N * K), where M <= 40 is number of rows, N <= 40 is number of columns in the grid, K <= M*N is number of obstacles we can eliminate.
Space: O(M * N * K)
```java
class Solution {
    private static final int[][] DIRS = new int[][] { {0, 1}, {0, -1}, {1, 0}, {-1, 0} };
    record Cell (int i, int j, int k) {}

    public int shortestPath(int[][] grid, int k) {
        int rows = grid.length, cols = grid[0].length;
        // if (k >= rows + cols - 3) return rows + cols - 2; // if you add this line, it will eliminate most of the test cases...
        boolean[][][] visited = new boolean[rows][cols][k + 1]; // k status can be from 0 - k
        Queue<Cell> q = new ArrayDeque<>();

        q.offer(new Cell(0, 0, k));
        visited[0][0][k] = true;

        int step = 0;

        while (!q.isEmpty()) {
            int size = q.size();
            while (size-- > 0) {
                Cell cur = q.poll();
                if (cur.i == rows - 1 && cur.j == cols - 1) return step;
                for (int[] dir : DIRS) {
                    int i = cur.i + dir[0], j = cur.j + dir[1], nextK;
                    if (i < 0 || j < 0 || i >= rows || j >= cols) continue;
                    if ((nextK = cur.k - grid[i][j]) == -1 || visited[i][j][nextK]) continue;

                    q.offer(new Cell(i, j, nextK));
                    visited[i][j][nextK] = true;
                }
            }
            step++;
        }

        return -1;
    }
}
```
