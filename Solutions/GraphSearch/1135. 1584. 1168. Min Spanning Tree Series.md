# Table of Content
1. [Context and References, it all greedy](#Context_and_References)
2. [1135. Connecting Cities With Minimum Cost](#1135_Connecting_Cities_With_Minimum_Cost)
   1. [Kruskal, Union Find, O(E*log(V)), 18ms, 100%](#1135_Kruskal_Union_Find)
   2. [Prim, min Heap, O(E*log(V)), 31ms, 87.72%](#1135_Prim)
3. [1584. Min Cost to Connect All Points](#1584_Min_Cost_to_Connect_All_Points)
   1. [Prim, Naive Implementation for dense graph, O(V^2), 18ms, 100%](#1584_Prim_Naive_for_Dense_Graph)
   2. [Kruskal, PriorityQueue, O(V^2log(V)), 88 ms, 91.92%](#1584_Kruskal_pq)
   3. [Kruskal, Sorted Array, O(V^2log(V)), 449ms, 47.97%](#1584_Kruskal_Sorted_Array)
   4. [Prim, PriorityQueue, O(V^2log(V)), 245 ms, 63.92%](#1584_Prim_Adjacency_List_PQ)
4. [1168. Optimize Water Distribution in a Village](#1168_Optimize_Water_Distribution_in_a_Village)
# Context_and_References
1. 王树森 最小生成树 Minimum Spanning Trees
   1. [What is Minimum Spanning Trees](https://www.youtube.com/watch?v=KsobpcI3dN0)
   2. [Prim](https://www.youtube.com/watch?v=GLlIaT_PxVE)
   3. [Kruskal](https://www.youtube.com/watch?v=Z4jm4o2bt28)
2. [12. Greedy Algorithms: Minimum Spanning Tree, MIT 6.046J Design and Analysis of Algorithms, Spring 2015](https://www.youtube.com/watch?v=tKwnms5iRBU)
3. MST:
   1. Minimum Spanning Trees, or "最小生成树" in Chinese
# [1135_Connecting_Cities_With_Minimum_Cost](https://leetcode.com/problems/connecting-cities-with-minimum-cost/)
## 1135_Kruskal_Union_Find
<pre>
TC: O(E*log(E)), or O(E*log(V))
For Sparse Graph: V*Log(V), good choice
For Dense  Graph: V^2*log(V), not as good as Naive Prim implementation which was O(V^2)
SC: O(V)
</pre>
```java
class Solution {
    public int minimumCost(int n, int[][] cons) {
        if (cons.length < n-1) return -1; // early termination
        Arrays.sort(cons, (a, b) -> a[2] - b[2]);
        
        UF uf = new UF(n+1);
        int res = 0;
        for (var e : cons) {
            if (uf.union(e[0], e[1])) res += e[2]; // only use the edge (add its weight) when node e[0] and e[1] is not already connected
            if (uf.size(e[0]) == n) return res; // got all n nodes in MST, time to return total weight
        }
        
        return -1; // never able to form a MST
    }

   static class UF { // this UF implementation maybe a bit confusing, but you could use whatever implementation you are familiar with
      private int[] roots;
      UF (int n) {
         roots = new int[n];
         Arrays.fill(roots, -1); // '-' means root, value means size, positive: parent
      }

      private int find(int x) {
         if (roots[x] < 0) return x;
         return roots[x] = find(roots[x]);
      }

      private boolean union(int x, int y) {
         int rx = find(x), ry = find(y);
         if (rx == ry) return false;
         if (-roots[rx] >= -roots[ry]) { // size of x > size of y
            roots[rx] += roots[ry];
            roots[ry] = rx;
         } else {
            roots[ry] += roots[rx];
            roots[rx] = ry;
         }
         return true;
      }

      private int size(int x) { // size of the set node x belongs(is connected) to
         return -roots[find(x)];
      }
   }
}
```
## 1135_Prim
<pre>
TC: O(E*log(E)) => O(E*log(V))
For Sparse Graph: V*Log(V), good choice
For Dense  Graph: V^2*log(V), not as good as Naive Prim implementation (refer to 1584) which was O(V^2)
SC: O(E)
</pre>

```java
class Solution {
    record Edge(int id, int w) {}
    public int minimumCost(int n, int[][] cons) {
        if (cons.length < n - 1) return -1; // not even enough edges, early termination
        // create adjacency list graph, V+E
        List<Edge>[] g = new List[n + 1];
        for (int i = 1; i <= n; i++) g[i] = new ArrayList<>();
        for (var e : cons) {
            g[e[0]].add(new Edge(e[1], e[2]));
            g[e[1]].add(new Edge(e[0], e[2]));
        }

        // Prim
        Queue<Edge> q = new PriorityQueue<>((a, b) -> Integer.compare(a.w, b.w));
        boolean[] connected = new boolean[n + 1]; // we use [1, n] as indicated by this problem
        for (Edge e : g[1]) q.offer(e); // add all edges from 1 to pq
        connected[1] = true; // so 1 is officially connected (in MST)

        int cnt = 1, res = 0; // starting with 1 is already in MST, so cnt = 1
        while (!q.isEmpty()) {
            Edge cur = q.poll(); // greedy, always check the edge with the smallest weight
            if (connected[cur.id]) continue;  // This is must, because an edge was valid earlier and added to pq can become invalid later
            connected[cur.id] = true; // this node is officially connected (part of MST)
            res += cur.w;
            if (++cnt == n) return res; // got n nodes connected, time to return total weight
            for (var e : g[cur.id]) if (!connected[e.id]) q.offer(e); // de-dup here is optional, but saves space
        }

        return -1; // never able to format a MST
    }
}

// slightly different way
class Solution {
   record Edge (int id, int cost) {}
   public int minimumCost(int n, int[][] cons) {
      if (cons.length < n-1) return -1; // not even enough edges, early termination
      // create adjacency list graph, V+E
      List<Edge>[] g = new List[n + 1];
      for (int i = 1; i <= n; i++) g[i] = new ArrayList<>();
      for (var e : cons) {
         g[e[0]].add(new Edge(e[1], e[2]));
         g[e[1]].add(new Edge(e[0], e[2]));
      }

      // Prim
      Queue<Edge> q = new PriorityQueue<>((a, b) -> Integer.compare(a.cost, b.cost));
      boolean[] connected = new boolean[n+1];
      q.offer(new Edge(1, 0)); // didn't connect any real edge yet, dummy starting edge

      int cnt = 0, res = 0; // cnt = 0: starting with 0 nodes in MST
      while (!q.isEmpty()) {
         Edge cur = q.poll();
         if (connected[cur.id]) continue; // This is must, because an edge was valid earlier and added to pq can become invalid later
         res += cur.cost;
         connected[cur.id] = true; // this node is officially connected (part of MST)
         if (++cnt == n) return res; // got n nodes connected, time to return total weight
         for (var e : g[cur.id]) if (!connected[e.id]) q.offer(e); // de-dup here is optional, but saves space
      }

      return -1; // never able to form a MST
   }
}
```
# [1584_Min_Cost_to_Connect_All_Points](https://leetcode.com/problems/min-cost-to-connect-all-points/)
## 1584_Prim_Naive_for_Dense_Graph
<pre>
TC: O(V^2)
In case of dense graph (this case, E ~ V^2)
This is better than Prim or Kruskal as they are V^2*log(V)
SC: O(V) (Min Dist)
</pre>
```java
class Solution {
   public int minCostConnectPoints(int[][] pts) {
      int n = pts.length, cnt = 1, res = 0, cur = 0;

      int[] minDist = new int[n]; // the distances from all nodes in MST to all the nodes not in MST
      boolean[] connected = new boolean[n]; // which node is connected, i.e. inside MST
      Arrays.fill(minDist, Integer.MAX_VALUE);
      connected[0] = true;

      while (cnt < n) { // we start with node 0 already connected (part of MST), so cnt = 1
         cnt++; // one more node (cur) is connected to MST
         int next = -1;
         for (int j = 0; j < n; j++) { // next will be the min weight edge from MST to rest of the nodes(not in MST)
            if (connected[j]) continue; // skip nodes already in MST
            minDist[j] = Math.min(minDist[j], dist(pts[cur], pts[j]));
            if (next == -1 || minDist[j] < minDist[next]) next = j;
         }
         connected[next] = true; // connected 
         res += minDist[next]; // add weight of selected edge to MST
         cur = next; // next become cur pick for next round
      }

      return res;
   }

   private int dist(int[] a, int[] b) {
      return Math.abs(a[0] - b[0]) + Math.abs(a[1] - b[1]);
   }
}
```
## 1584_Kruskal
<pre>
TC: E*log(E) => O(V^2*log(V))
SC: E => O(V^2)
</pre>
### 1584_Kruskal_pq
```java
class Solution {
   record Edge (int i, int j, int w) {}

   static class UF {
      private int[] roots;
      UF (int n) {
         roots = new int[n];
         Arrays.fill(roots, -1); // '-' means root, value means size, positive: parent
      }

      private int find(int x) {
         if (roots[x] < 0) return x;
         return roots[x] = find(roots[x]);
      }

      private boolean union(int x, int y) {
         int rx = find(x), ry = find(y);
         if (rx == ry) return false;
         if (-roots[rx] >= -roots[ry]) { // size of x > size of y
            roots[rx] += roots[ry];
            roots[ry] = rx;
         } else {
            roots[ry] += roots[rx];
            roots[rx] = ry;
         }
         return true;
      }

      private int size(int x) {
         return -roots[find(x)];
      }
   }

   public int minCostConnectPoints(int[][] pts) {
      int n = pts.length;
      if (n == 1) return 0;

      Queue<Edge> q = new PriorityQueue<>(Math.max(n*(n-1)/2, 10), (a, b) -> Integer.compare(a.w, b.w));
      int idx = 0;
      for (int i = 0; i < n; i++) for (int j = i+1; j < n; j++)
         q.offer(new Edge(i, j, Math.abs(pts[i][0] - pts[j][0]) + Math.abs(pts[i][1] - pts[j][1])));


      UF uf = new UF(n);
      int res = 0;
      while (!q.isEmpty()) {
         Edge e = q.poll();
         if (uf.union(e.i, e.j)) res += e.w;
         if (uf.size(e.i) == n) return res;
      }

      return -1;
   }
}
```
### 1584_Kruskal_Sorted_Array
```java
class Solution {
   record Edge (int i, int j, int w) {}
   public int minCostConnectPoints(int[][] pts) {
      int n = pts.length;
      if (n == 1) return 0;

      Edge[] edges = new Edge[n*(n-1)/2];
      for (int i = 0, idx = 0; i < n; i++) for (int j = i+1; j < n; j++)
         edges[idx++] = new Edge(i, j, Math.abs(pts[i][0] - pts[j][0]) + Math.abs(pts[i][1] - pts[j][1]));

      Arrays.sort(edges, (a, b) -> Integer.compare(a.w, b.w));

      UF uf = new UF(n);
      int res = 0;
      for (var e : edges) {
         if (uf.union(e.i, e.j)) res += e.w;
         if (uf.size(e.i) == n) return res;
      }

      return -1;
   }

   static class UF {
      private int[] roots;
      UF (int n) {
         roots = new int[n];
         Arrays.fill(roots, -1); // '-' means root, value means size, positive: parent
      }

      private int find(int x) {
         if (roots[x] < 0) return x;
         return roots[x] = find(roots[x]);
      }

      private boolean union(int x, int y) {
         int rx = find(x), ry = find(y);
         if (rx == ry) return false;
         if (-roots[rx] >= -roots[ry]) { // size of x > size of y
            roots[rx] += roots[ry];
            roots[ry] = rx;
         } else {
            roots[ry] += roots[rx];
            roots[rx] = ry;
         }
         return true;
      }

      private int size(int x) {
         return -roots[find(x)];
      }
   }
}
```
## 1584_Prim_Adjacency_List_PQ
mean maybe 500 ms
<pre>
TC: O(E*log(E)) => O(V^2)log(V)
SC: O(V^2)
</pre>
```java
class Solution {
   record Edge(int id, int w) {}
   public int minCostConnectPoints(int[][] pts) {
      int n = pts.length;

      List<Edge>[] g = new List[n];
      for (int i = 0; i < n; i++) g[i] = new ArrayList<>();
      for (int i = 0; i < n; i++)
         for (int j = i + 1; j < n; j++) {
            int w = Math.abs(pts[i][0] - pts[j][0]) + Math.abs(pts[i][1] - pts[j][1]);
            g[i].add(new Edge(j, w));
            g[j].add(new Edge(i, w));
         }

      Queue<Edge> q = new PriorityQueue<>((a, b) -> Integer.compare(a.w, b.w));
      boolean[] connected = new boolean[n];
      for (var e : g[0]) q.offer(e);
      connected[0] = true;

      int cnt = 1, res = 0;
      while (cnt < n) { // [1, n-1], total n-1 edges used, or you could say n-1 new nodes added, in additional to 0
         Edge cur = q.poll();
         if (connected[cur.id]) continue;
         res += cur.w;
         connected[cur.id] = true;
         ++cnt;
         for (var e : g[cur.id]) q.offer(e);
      }

      return res;
   }
}
```
# [1168_Optimize_Water_Distribution_in_a_Village](https://leetcode.com/problems/optimize-water-distribution-in-a-village/)
<pre>
</pre>
```java

```