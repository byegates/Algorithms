# [1135. Connecting Cities With Minimum Cost](https://leetcode.com/problems/connecting-cities-with-minimum-cost/)
## Kruskal (Greedy, Union Find), 18ms, 100%
<pre>
TC: O(E*log(E)), or O(E*log(V))
SC: O(V)
</pre>
```java
class Solution {
    static class UF {
        private int[] roots;
        UF (int n) {
            roots = new int[n];
            Arrays.fill(roots, -1); // '-' means root, value means size, positive: parent
        }

        private int find(int x) {
            if (roots[x] < 0) return x;
            return roots[x] = find(roots[x]);
        }
        
        private boolean union(int x, int y) {
            int rx = find(x), ry = find(y);
            if (rx == ry) return false;
            if (-roots[rx] >= -roots[ry]) { // size of x > size of y
                roots[rx] += roots[ry];
                roots[ry] = rx;
            } else {
                roots[ry] += roots[rx];
                roots[rx] = ry;
            }
            return true;
        }
        
        private int size(int x) {
            return -roots[find(x)];
        }
    }

    public int minimumCost(int n, int[][] cons) {
        if (cons.length < n-1) return -1; // early termination
        Arrays.sort(cons, (a, b) -> a[2] - b[2]);
        
        UF uf = new UF(n+1);
        int res = 0;
        for (var e : cons) {
            if (uf.union(e[0], e[1])) res += e[2];
            if (uf.size(e[0]) == n) break;
        }
        
        return uf.size(1) == n ? res : -1;
    }
}
```
## prim (greedy), 31ms, 87.72%
<pre>
TC: O(E*log(E)) => O(E*log(V))
SC: O(E)
</pre>

```java
class Solution {
    record Edge(int id, int w) {}
    public int minimumCost(int n, int[][] cons) {
        if (cons.length < n - 1) return -1; // early termination
        // create graph, V+E
        List<Edge>[] g = new List[n + 1];
        for (int i = 1; i <= n; i++) g[i] = new ArrayList<>();
        for (var e : cons) {
            g[e[0]].add(new Edge(e[1], e[2]));
            g[e[1]].add(new Edge(e[0], e[2]));
        }

        // Prim
        Queue<Edge> q = new PriorityQueue<>((a, b) -> Integer.compare(a.w, b.w));
        boolean[] connected = new boolean[n + 1];
        for (Edge e : g[1]) q.offer(e);
        connected[1] = true;

        int cnt = 1, res = 0;
        while (!q.isEmpty()) {
            Edge cur = q.poll();
            if (connected[cur.id]) continue;
            connected[cur.id] = true;
            res += cur.w;
            if (++cnt == n) break;
            for (var e : g[cur.id]) q.offer(e);
        }

        return cnt == n ? res : -1;
    }
}
```
# [1584. Min Cost to Connect All Points](https://leetcode.com/problems/min-cost-to-connect-all-points/)
## Kruskal
<pre>
TC: E*log(E) => O(V^2*log(V))
SC: E => O(V^2)
</pre>
### pq 88 ms, 91.92%
```java
class Solution {
    record Edge (int i, int j, int w) {}

    static class UF {
        private int[] roots;
        UF (int n) {
            roots = new int[n];
            Arrays.fill(roots, -1); // '-' means root, value means size, positive: parent
        }

        private int find(int x) {
            if (roots[x] < 0) return x;
            return roots[x] = find(roots[x]);
        }
        
        private boolean union(int x, int y) {
            int rx = find(x), ry = find(y);
            if (rx == ry) return false;
            if (-roots[rx] >= -roots[ry]) { // size of x > size of y
                roots[rx] += roots[ry];
                roots[ry] = rx;
            } else {
                roots[ry] += roots[rx];
                roots[rx] = ry;
            }
            return true;
        }
        
        private int size(int x) {
            return -roots[find(x)];
        }
    }

    public int minCostConnectPoints(int[][] pts) {
        int n = pts.length;
        
        Queue<Edge> q = new PriorityQueue<>(Math.max(n*(n-1)/2, 10), (a, b) -> Integer.compare(a.w, b.w));
        int idx = 0;
        for (int i = 0; i < n; i++) for (int j = i+1; j < n; j++)
            q.offer(new Edge(i, j, Math.abs(pts[i][0] - pts[j][0]) + Math.abs(pts[i][1] - pts[j][1])));
        

        UF uf = new UF(n);
        int res = 0;
        while (!q.isEmpty()) {
            Edge e = q.poll();
            if (uf.union(e.i, e.j)) res += e.w;
            if (uf.size(e.i) == n) break;
        }
        
        return uf.size(0) == n ? res : -1;
    }
}
```
### Array Sort, 449ms, 47.97%
```java
class Solution {
    record Edge (int i, int j, int w) {}

    static class UF {
        private int[] roots;
        UF (int n) {
            roots = new int[n];
            Arrays.fill(roots, -1); // '-' means root, value means size, positive: parent
        }

        private int find(int x) {
            if (roots[x] < 0) return x;
            return roots[x] = find(roots[x]);
        }
        
        private boolean union(int x, int y) {
            int rx = find(x), ry = find(y);
            if (rx == ry) return false;
            if (-roots[rx] >= -roots[ry]) { // size of x > size of y
                roots[rx] += roots[ry];
                roots[ry] = rx;
            } else {
                roots[ry] += roots[rx];
                roots[rx] = ry;
            }
            return true;
        }
        
        private int size(int x) {
            return -roots[find(x)];
        }
    }

    public int minCostConnectPoints(int[][] pts) {
        int n = pts.length;
        
        Edge[] edges = new Edge[n*(n-1)/2];
        int idx = 0;
        for (int i = 0; i < n; i++) for (int j = i+1; j < n; j++)
            edges[idx++] = new Edge(i, j, Math.abs(pts[i][0] - pts[j][0]) + Math.abs(pts[i][1] - pts[j][1]));
        
        Arrays.sort(edges, (a, b) -> Integer.compare(a.w, b.w));

        UF uf = new UF(n);
        int res = 0;
        for (var e : edges) {
            if (uf.union(e.i, e.j)) res += e.w;
            if (uf.size(e.i) == n) break;
        }
        
        return uf.size(0) == n ? res : -1;
    }
}
```
## Prim, 245 ms, 63.92%
mean maybe 500 ms
<pre>
TC: O(E*log(E)) => O(V^2)log(V)
SC: O(V^2)
</pre>
```java
class Solution {
    record Edge (int id, int w) {}
    public int minCostConnectPoints(int[][] pts) {
        int n = pts.length;

        List<Edge>[] g = new List[n];
        for (int i = 0; i < n; i++) g[i] = new ArrayList<>();
        for (int i = 0; i < n; i++) for (int j = i+1; j < n; j++) {
            int w = Math.abs(pts[i][0] - pts[j][0]) + Math.abs(pts[i][1] - pts[j][1]);
            g[i].add(new Edge(j, w));
            g[j].add(new Edge(i, w));
        }

        Queue<Edge> q = new PriorityQueue<>((a, b) -> Integer.compare(a.w, b.w));
        boolean[] connected = new boolean[n];
        for (var e : g[0]) q.offer(e);
        connected[0] = true;

        int cnt = 1, res = 0;
        while (!q.isEmpty()) {
            Edge cur = q.poll();
            if (connected[cur.id]) continue;
            res += cur.w;
            connected[cur.id] = true;
            if (++cnt == n) break;
            for (var e : g[cur.id]) q.offer(e);
        }

        return res;
    }
}

// slightly different way
class Solution {
    record Edge (int id, int cost) {}
    public int minimumCost(int n, int[][] cons) {
        if (cons.length < n-1) return -1; // early termination
        // create graph
        List<Edge>[] g = new List[n+1];
        for (var e : cons) {
            if (g[e[0]] == null) g[e[0]] = new ArrayList<>();
            if (g[e[1]] == null) g[e[1]] = new ArrayList<>();
            g[e[0]].add(new Edge(e[1], e[2]));
            g[e[1]].add(new Edge(e[0], e[2]));
        }

        // Prim
        Queue<Edge> q = new PriorityQueue<>((a, b) -> Integer.compare(a.cost, b.cost));
        boolean[] visited = new boolean[n+1];
        q.offer(new Edge(1, 0));

        int cnt = 0, res = 0;
        while (!q.isEmpty()) {
            Edge cur = q.poll();
            if (visited[cur.id]) continue;
            res += cur.cost;
            visited[cur.id] = true;
            if (++cnt == n) break;
            for (var e : g[cur.id]) q.offer(e);
        }

        return cnt == n ? res : -1;
    }
}
```
## Prim for Dense Graph, 32ms, 98.74%
<pre>
TC: O(V^2)
SC: O(V^2)
</pre>
```java
class Solution {
    public int minCostConnectPoints(int[][] pts) {
        int n = pts.length;
        // create adjacent matrix 
        int[][] w = new int[n][n];
        for (int i = 0; i < n; i++) for (int j = i+1; j < n; j++)
            w[i][j] = w[j][i] = Math.abs(pts[i][0] - pts[j][0]) + Math.abs(pts[i][1] - pts[j][1]);

        boolean[] connected = new boolean[n];
        int[] minDist = new int[n];
        Arrays.fill(minDist, Integer.MAX_VALUE);
        minDist[0] = 0;

        int cnt = 0, res = 0;
        for (int i = 0; i < n; i++) {
            int next = -1;
            for (int j = 0; j < n; j++)
                if(!connected[j] && (next == -1 || minDist[j] < minDist[next]))
                    next = j;
            connected[next] = true;
            res += minDist[next];
            if (++cnt == n) break;
            for (int j = 0; j < n; j++) if (!connected[j]) minDist[j] = Math.min(minDist[j], w[next][j]);
        }

        return cnt == n ? res : -1;
    }
}
```
#[1168. Optimize Water Distribution in a Village](https://leetcode.com/problems/optimize-water-distribution-in-a-village/)
<pre>
</pre>
```java

```