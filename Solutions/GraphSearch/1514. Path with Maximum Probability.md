[1514. Path with Maximum Probability](https://leetcode.com/problems/path-with-maximum-probability/)

## cost, 25ms, 99.21%
```java
class Solution {
    record Edge (int i, double w) {}
    public double maxProbability(int n, int[][] edges, double[] succProb, int src, int dst) {
        // create adjacency list graph, with double directed edges for un-directed graph
        List<Edge>[] g = new List[n];
        for (int i = 0; i < n; i++) g[i] = new ArrayList<>();
        for (int i = 0; i < edges.length; i++) {
            int a = edges[i][0], b = edges[i][1];
            double w = succProb[i];
            g[a].add(new Edge(b, w));
            g[b].add(new Edge(a, w));
        }
        
        // Dijkstra
        Queue<Edge> q = new PriorityQueue<>((a, b) -> Double.compare(b.w, a.w));
        q.offer(new Edge(src, 1.0));
        double[] best = new double[n];
        Arrays.fill(best, Double.NEGATIVE_INFINITY);

        while (!q.isEmpty()) {
            Edge cur = q.poll();
            if (cur.i == dst) return cur.w;
            
            for (var e : g[cur.i]) {
                double w = e.w * cur.w;
                if (w <= best[e.i]) continue;
                q.offer(new Edge(e.i, w));
                best[e.i] = w;
            }
        }
        
        return 0;
    }
}
```
## only boolean, 32 ms, 97.12%
```java
class Solution {
    record Edge (int i, double w) {}
    public double maxProbability(int n, int[][] edges, double[] succProb, int src, int dst) {
        // create adjacency list graph, with double directed edges for un-directed graph
        List<Edge>[] g = new List[n];
        for (int i = 0; i < n; i++) g[i] = new ArrayList<>();
        for (int i = 0; i < edges.length; i++) {
            int a = edges[i][0], b = edges[i][1];
            double w = succProb[i];
            g[a].add(new Edge(b, w));
            g[b].add(new Edge(a, w));
        }
        
        // Dijkstra
        Queue<Edge> q = new PriorityQueue<>((a, b) -> Double.compare(b.w, a.w));
        q.offer(new Edge(src, 1.0));
        boolean[] visited = new boolean[n];
        
        while (!q.isEmpty()) {
            Edge cur = q.poll();
            if (cur.i == dst) return cur.w;
            visited[cur.i] = true;
            
            for (var e : g[cur.i]) if (!visited[e.i])
                q.offer(new Edge(e.i, e.w * cur.w));
        }
        
        return 0;
    }
}
```