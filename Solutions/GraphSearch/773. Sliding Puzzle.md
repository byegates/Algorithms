# [773. Sliding Puzzle](https://leetcode.com/problems/sliding-puzzle/)
## bfs, 8ms, 92.84%
```java
class Node {
    private static int m = 2, n = 3;
    private int i0, j0;
    private int[][] board;
    
    public Node(int[][] b) {
        board = new int[m][n];
        for (int i = 0; i < m; i++) for (int j = 0; j < n; j++) {
            board[i][j] = b[i][j];
            if (b[i][j] == 0) {
                i0 = i;
                j0 = j;
            }
        }
    }
    
    public Node() {
        board = new int[m][n];
        int k = 1;
        for (int i = 0; i < m; i++) for (int j = 0; j < n; j++) board[i][j] = (k++) % 6;
        i0 = 1;
        j0 = 2;
    }
    
    public Node clone() {
        return new Node(board);
    }
    
    public void move(int i2, int j2) {
        board[i0][j0] = board[i2][j2];
        board[i2][j2] = 0;
        i0 = i2;
        j0 = j2;
    }
    
    public int[] nextIdx(int[] dir) {
        return new int[]{i0 + dir[0], j0 + dir[1]};
    }
    
    @Override
    public int hashCode() {
        int code = 0;
        for (var row : board) for (int x : row) code = code * 10 + x;
        return code;
    }
    @Override
    public boolean equals(Object o) {
        if (o == this) return true;
        // if (o == null) return false;
        if (! (o instanceof Node n)) return false;
        return hashCode() == n.hashCode();
    }
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append(Arrays.toString(board[0])).append("\n").append(Arrays.toString(board[1])).append("\n");
        return sb.toString();
    }
}

class Solution {
    private static int[][] dirs = new int[][] {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
    public int slidingPuzzle(int[][] board) {
        Set<Node> set = new HashSet<>();
        Queue<Node> q = new ArrayDeque<>();
        
        Node start = new Node(board);
        q.offer(start);
        set.add(start);
        
        Node end = new Node();
        
        int steps = 0;
        while (!q.isEmpty()) {
            for (int size = q.size(); size > 0; size--) {
                Node cur = q.poll();
                if (cur.equals(end)) return steps;
                for (var dir : dirs) {
                    int[] nextIdx = cur.nextIdx(dir);
                    int i2 = nextIdx[0], j2 = nextIdx[1];
                    if (i2 < 0 || j2 < 0 || i2 >= 2 || j2 >= 3) continue;
                    Node next = cur.clone();
                    next.move(i2, j2);
                    if (!set.add(next)) continue;
                    q.offer(next);
                }
            }
            steps++;            
        }
        
        return -1;
    }
}
```
