# 685. Redundant Connection II

```java
class Solution {
    public int[] findRedundantDirectedConnection(int[][] edges) {
        int[] parent = new int[edges.length + 1];
        
        for (var edge : edges) // found two edges with common child 
            if (parent[edge[1]] == 0) parent[edge[1]] = edge[0];
            else {
                int[] dup1 = new int[] {parent[edge[1]], edge[1]};
                int[] cycle = cycleEdge(edges, edge); // edge is dup2
                return cycle == null ? edge : dup1;
            }
        
        return cycleEdge(edges, null);
    }
    
    private int[] cycleEdge(int[][] edges, int[] edgeToSkip) {
        int[] roots = new int[edges.length + 1];
        
        for (int i = 0; i < roots.length; i++) roots[i] = i;
        
        for (var edge : edges) {
            if (edgeToSkip != null && edge[0] == edgeToSkip[0] && edge[1] == edgeToSkip[1]) continue;
            int p = edge[0], c = edge[1];
            if (findRoot(roots, c) == findRoot(roots, p)) return edge;
            else if (roots[c] == c) roots[c] = findRoot(roots, p);
        }
        
        return null;
    }
    
    private int findRoot(int[] roots, int a) {
        if (roots[a] != a) roots[a] = findRoot(roots, roots[a]);
        return roots[a];
    }
}
```

# 684. Redundant  (0 ms)
极简版union find...
```java
class Solution {
    public int[] findRedundantConnection(int[][] edges) {
        int[] roots = new int[edges.length + 1];

        for (int i = 0; i < roots.length; i++) roots[i] = i;

        for (var edge : edges) {
            int root0 = findRoot(roots, edge[0]);
            int root1 = findRoot(roots, edge[1]);
            int p = edge[0], c = edge[1];
            if (root0 == root1) return edge;
            roots[root0] = root1;
        }

        return null;
    }

    private int findRoot(int[] roots, int a) {
        if (roots[a] != a) roots[a] = findRoot(roots, roots[a]);
        return roots[a];
    }
}
```