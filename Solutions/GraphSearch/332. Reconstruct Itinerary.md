# LC 332. Reconstruct Itinerary
[332. Reconstruct Itinerary](https://leetcode.com/problems/reconstruct-itinerary/)

[LaiCode 466. Reconstruct Itinerary](https://app.laicode.io/app/problem/466)

[èŠ±èŠ±é…± LeetCode 332. Reconstruct Itinerary - åˆ·é¢˜æ‰¾å·¥ä½œ EP52](https://www.youtube.com/watch?v=4udFSOWQpdg)

[332 - Reconstruct Itineraryã€FLAGé«˜é¢‘ç²¾é€‰é¢è¯•é¢˜è®²è§£ã€‘](https://www.youtube.com/watch?v=LKSdX31pXjY)

## Solution 1 DFS

TC: LaiOffer: O(n + nlogn + (n-1)!), LeetCode: E^d, where |E|âˆ£Eâˆ£ is the number of total flights and dd is the maximum number of flights from an airport.

SC: LaiOffer: O(n), LeetCode: O(V+E)

```java
class Solution {
    public List<String> findItinerary(List<List<String>> tickets) {
        Map<String, List<String>> graph = createGraph(tickets);
        Map<String, boolean[]> visited = createVisited(graph);
        List<String> sol = new ArrayList<>(tickets.size() + 1);
        dfs("JFK", sol, graph, visited, tickets.size());
        return sol;
    }

    public boolean dfs(String cur, List<String> sol, Map<String, List<String>> graph, Map<String, boolean[]> visited, int n) {

        sol.add(cur);
        if (sol.size() == n + 1) return true;

        List<String> neighbors = graph.get(cur);

        if (neighbors == null) {
            sol.remove(sol.size() - 1);
            return false;
        }

        boolean[] v = visited.get(cur);
        for (int i = 0; i < neighbors.size(); i++) {
            String nei = neighbors.get(i);
            if (v[i]) continue;
            v[i] = true;
            if (dfs(nei, sol, graph, visited, n)) return true;
            v[i] = false;
        }

        sol.remove(sol.size() - 1);
        return false;
    }

    private Map<String, boolean[]> createVisited(Map<String, List<String>> graph) {
        Map<String, boolean[]> visited = new HashMap<>();

        for (Map.Entry<String, List<String>> set : graph.entrySet()) {
            Collections.sort(set.getValue());
            visited.put(set.getKey(), new boolean[set.getValue().size()]);
        }


        return visited;
    }

    public Map<String, List<String>> createGraph(List<List<String>> tickets) {
        Map<String, List<String>> graph = new HashMap<>();
        for (var edge : tickets) {
            String start = edge.get(0), end = edge.get(1);
            List<String> edges = graph.get(start);
            if (edges == null) {
                edges = new ArrayList<>();
                graph.put(start, edges);
            }

            edges.add(end);
        }
        return graph;
    }
}
```

## 
### æ¬§æ‹‰è·¯å¾„ (1736)
[ä¸€ç¬”ç”»é—®é¢˜](https://zh.wikipedia.org/wiki/%E4%B8%80%E7%AC%94%E7%94%BB%E9%97%AE%E9%A2%98)
[Eulerian path](https://en.wikipedia.org/wiki/Eulerian_path)

[æŸ¯å°¼æ–¯å ¡ä¸ƒæ¡¥é—®é¢˜](https://zh.wikipedia.org/wiki/%E6%9F%AF%E5%B0%BC%E6%96%AF%E5%A0%A1%E4%B8%83%E6%A1%A5%E9%97%AE%E9%A2%98)
![](../Images/7æ¡¥é—®é¢˜.png)

[æ¬§æ‹‰é“è·¯ä¸æ¬§æ‹‰å›è·¯](https://www.youtube.com/watch?v=vjpzmnVuHjw)
æ¬§æ‹‰å›è·¯: æ— å‘å›¾: è¿é€šå›¾ä¸”æ‰€æœ‰å®šç‚¹éƒ½æ˜¯å¶æ•°åº¦, æœ‰å‘å›¾: å‡ºåº¦å…¥åº¦ç›¸ç­‰

æ¬§æ‹‰è·¯å¾„: è¿é€šå›¾ä¸”å¥‡æ•°åº¦çš„ç‚¹ä¸è¶…è¿‡ä¸¤ä¸ªï¼Œ
æ— å‘å›¾: æœ‰ä¸”åªæœ‰1ä¸ªå‡ºåº¦æ¯”å…¥åº¦å¤šä¸€ä¸ª(æ¬§æ‹‰è·¯å¾„èµ·ç‚¹) && æœ‰ä¸”åªæœ‰1ä¸ªå…¥è¯»æ¯”å‡ºåº¦å¤šä¸€ä¸ª(ç»ˆç‚¹ğŸ) && å…¶ä»–æ‰€æœ‰ç‚¹å‡ºåº¦=å…¥åº¦ || æ‰€æœ‰ç‚¹å‡ºåº¦=å…¥åº¦

å·²çŸ¥å›¾ä¸Šå­˜åœ¨æ¬§æ‹‰è·¯å¾„ï¼Œæ‰¾åˆ°ä¸€ä¸ªæ¬§æ‹‰è·¯å¾„:
[Hierholzerâ€™s Algorithm](https://slaystudy.com/hierholzers-algorithm/) () O(E)

[Fleuryâ€™s algorithm](https://slaystudy.com/fleurys-algorithm/) O(E^2)
