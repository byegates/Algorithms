# LC 332. Reconstruct Itinerary
[332. Reconstruct Itinerary](https://leetcode.com/problems/reconstruct-itinerary/)
| [LaiCode 466. Reconstruct Itinerary](https://app.laicode.io/app/problem/466)

[èŠ±èŠ±é…± LeetCode 332. Reconstruct Itinerary - åˆ·é¢˜æ‰¾å·¥ä½œ EP52](https://www.youtube.com/watch?v=4udFSOWQpdg)

[LaiOffer: 332 - Reconstruct Itineraryã€FLAGé«˜é¢‘ç²¾é€‰é¢è¯•é¢˜è®²è§£ã€‘](https://www.youtube.com/watch?v=LKSdX31pXjY)

## Solution 1 DFS

TC: LaiOffer: O(E + Elog(E) + (E)!), LeetCode: E^d, where |E|âˆ£Eâˆ£ is the number of total flights and dd is the maximum number of flights from an airport.

SC: LaiOffer: O(E), LeetCode: O(V+E)

```java
class Solution {
    public List<String> findItinerary(List<List<String>> tickets) {
        Map<String, List<String>> graph = createGraph(tickets);
        graph.forEach((key, val) -> Collections.sort(val));

        // create boolean array for each node for edge de-dup
        Map<String, boolean[]> visited = new HashMap<>();
        graph.forEach((key, val) -> visited.put(key, new boolean[val.size()]));

        List<String> sol = new ArrayList<>(tickets.size() + 1);
        sol.add("JFK");
        dfs("JFK", sol, graph, visited, tickets.size() + 1);
        return sol;
    }

    public boolean dfs(String cur, List<String> sol, Map<String, List<String>> graph, Map<String, boolean[]> visited, int n) {
        if (sol.size() == n) return true;

        List<String> neighbors = graph.get(cur);

        if (neighbors == null) return false;

        boolean[] v = visited.get(cur);
        for (int i = 0; i < neighbors.size(); i++) {
            String nei = neighbors.get(i);
            if (v[i]) continue;
            sol.add(nei);
            v[i] = true;
            if (dfs(nei, sol, graph, visited, n)) return true;
            sol.remove(sol.size() - 1);
            v[i] = false;
        }

        return false;
    }

    public Map<String, List<String>> createGraph(List<List<String>> tickets) {
        Map<String, List<String>> graph = new HashMap<>();
        for (var edge : tickets) {
            String start = edge.get(0), end = edge.get(1);
            List<String> edges = graph.get(start);
            if (edges == null) {
                edges = new ArrayList<>();
                graph.put(start, edges);
            }

            edges.add(end);
        }
        return graph;
    }
}
```

## 
### æ¬§æ‹‰è·¯å¾„ (1736)
[ä¸€ç¬”ç”»é—®é¢˜](https://zh.wikipedia.org/wiki/%E4%B8%80%E7%AC%94%E7%94%BB%E9%97%AE%E9%A2%98)
[Eulerian path](https://en.wikipedia.org/wiki/Eulerian_path)

[æŸ¯å°¼æ–¯å ¡ä¸ƒæ¡¥é—®é¢˜](https://zh.wikipedia.org/wiki/%E6%9F%AF%E5%B0%BC%E6%96%AF%E5%A0%A1%E4%B8%83%E6%A1%A5%E9%97%AE%E9%A2%98)
![](../Images/7æ¡¥é—®é¢˜.png)

7æ¡¥é—®é¢˜æ— è§£ï¼Œå› ä¸ºæ‰€æœ‰ç‚¹éƒ½æ˜¯å¥‡æ•°åº¦ã€‚

### å……åˆ†æ¡ä»¶
#### æ¬§æ‹‰å›è·¯ 
å¿…é¡»æ˜¯è¿é€šå›¾ &&:

**æ— å‘å›¾**: è¿é€šå›¾ä¸”æ‰€æœ‰å®šç‚¹éƒ½æ˜¯å¶æ•°åº¦

**æœ‰å‘å›¾**: å‡ºåº¦å…¥åº¦ç›¸ç­‰

#### æ¬§æ‹‰è·¯å¾„ 

å¿…é¡»æ˜¯è¿é€šå›¾ &&

**æœ‰å‘å›¾**: ä¸”å¥‡æ•°åº¦çš„ç‚¹æ˜¯2ä¸ªæˆ–è€…0ä¸ª(0ä¸ªå°±æ˜¯æ¬§æ‹‰å›è·¯/ç¯)

**æ— å‘å›¾**: æœ‰ä¸”åªæœ‰1ä¸ªå‡ºåº¦æ¯”å…¥åº¦å¤šä¸€ä¸ª(æ¬§æ‹‰è·¯å¾„èµ·ç‚¹) && æœ‰ä¸”åªæœ‰1ä¸ªå…¥è¯»æ¯”å‡ºåº¦å¤šä¸€ä¸ª(ç»ˆç‚¹ğŸ) && å…¶ä»–æ‰€æœ‰ç‚¹å‡ºåº¦=å…¥åº¦ || æ‰€æœ‰ç‚¹å‡ºåº¦=å…¥åº¦ (æ¬§æ‹‰å›è·¯)

[æ¬§æ‹‰é“è·¯ä¸æ¬§æ‹‰å›è·¯](https://www.youtube.com/watch?v=vjpzmnVuHjw)

[Existence of Eulerian Paths and Circuits | Graph Theory](https://www.youtube.com/watch?v=xR4sGgwtR2I&list=PLDV1Zeh2NRsDGO4--qE8yH72HFL1Km93P&index=28)

### å·²çŸ¥å›¾ä¸Šå­˜åœ¨æ¬§æ‹‰è·¯å¾„ï¼Œæ‰¾åˆ°ä¸€ä¸ªæ¬§æ‹‰è·¯å¾„
[Hierholzerâ€™s Algorithm](https://slaystudy.com/hierholzers-algorithm/) O(E)

[Eulerian Path/Circuit algorithm (Hierholzer's algorithm) | Graph Theory](https://www.youtube.com/watch?v=8MpoO2zA2l4&list=PLDV1Zeh2NRsDGO4--qE8yH72HFL1Km93P&index=29)

[Fleuryâ€™s algorithm](https://slaystudy.com/fleurys-algorithm/) O(E^2) å…ˆä¸è®²äº†

TC: O(E)

SC: O(E)
```java
class Solution {
    public List<String> findItinerary(List<List<String>> tickets) {
        Map<String, LinkedList<String>> graph = createGraph(tickets);
        graph.forEach((key, val) -> Collections.sort(val));
        LinkedList<String> sol = new LinkedList<>();
        dfs("JFK", sol, graph);
        return sol;
    }

    public void dfs(String cur, LinkedList<String> sol, Map<String, LinkedList<String>> graph) {
        LinkedList<String> neighbors = graph.get(cur);

        if (neighbors != null)
            while (!neighbors.isEmpty())
                dfs(neighbors.pollFirst(), sol, graph);

        sol.offerFirst(cur);
    }

    public Map<String, LinkedList<String>> createGraph(List<List<String>> tickets) {
        Map<String, LinkedList<String>> graph = new HashMap<>();
        for (var edge : tickets) {
            String start = edge.get(0), end = edge.get(1);
            LinkedList<String> edges = graph.get(start);
            if (edges == null)
                graph.put(start, edges = new LinkedList<>());
            edges.add(end);
        }
        return graph;
    }
}
```