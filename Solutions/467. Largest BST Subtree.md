# Largest BST Subtree
## Description
Given a binary tree, find the largest subtree which is a Binary Search Tree (BST), where largest means subtree with largest number of nodes in it.

Note:
A subtree must include all of its descendants.
Here's an example:

<pre>
   10
   / \
  5  15
 / \   \
1   8   7
</pre>

The Largest BST Subtree in this case is
<pre>
  5
 / \
1   8
</pre>
The return value is the subtree's size, which is 3.

Follow up:
Can you figure out ways to solve it with O(n) time complexity?

## Analysis
This is similar to the problem where we check whether a tree is complete tree in O(n) time.
In that problem we calculate tree height and determine whether tree is complete or not at the same, and we only need to traverse the tree one time.

We could do similar thing here, but there's more work we need to do,
we need to know the min and max value of both left and right subtree at all time,
to determine whether it's a BST or not;
we also need to know the size of any subtree. (could use -1 to say the tree is not BST, and we don't care about the size)

### Base/Corner Case
If given Binary Tree is null, we return 0 immediately, do not let null node gets into Recursion.

### What do we do at current level
If left and right subtree are both BST, return size(left size + right size + 1), min(left.min), max(right.max);

If (left subtree is null) return size(0 + right size + 1), min(root.key), max(right.max);

If (right subtree is null) return size(left size + 0 + 1), min(left.min), max(root.key);

Update the size to global max for all above cases before return.

If (left subtree is not BST or right subtree is not BST) return -1 or null to indicate this while subtree is not BST, do not update global max, min and max value do not matter now. (you can return anything)

### What do we want to subtrees (What do we return to parent nodes)
Whether I am a BST

If BST, the size, min value, max value of whole subtree

### What do we do for null subtrees?
size 0, min and max value is tricky

## Code

### Easier to understand?
This is a re-org of above analysis.
Because null node can't get into Recursion, so once we are in recursion logic, we have at least one node, so we start with size 1, and the max and min value range will both default to root value itself (if it's a leaf node).

If left node is not null, we traverse to left node, get the size and left subtree min, max value range.
If size returned from left subtree is -1 that means left subtree is not BST,
so only when left subtree size is not -1 and root.key > left.Max,
we may have a valid tree at current level, so we add left size to current tree size and update cur.Min to left.Min.

Then weo do the same logic to right subtree.

Last step we update global max with size and then return the whole cur subtree result to parent level.
```java
class Solution {
    static class Result {
        int size, min, max;

        Result(int size, int min, int max) {
            this.size = size;
            this.min = min;
            this.max = max;
        }
    }

    public int largestBSTSubtree(TreeNode root) {
        if (root == null) return 0;
        int[] res = new int[1];
        dfs(root, res);
        return res[0];
    }

    private Result dfs(TreeNode root, int[] res) {
        // root will not be null, so the size is at least 1
        Result cur = new Result(1, root.key, root.key);
        
        if (root.left != null) {
            Result left = dfs(root.left, res);
            if (left.size != -1 && root.key > left.max) {
                cur.min = left.min;
                cur.size += left.size;
            } else cur.size = -1;
        }

        if (root.right != null) {
            Result right = dfs(root.right, res);
            if (right.size != -1 && root.key < right.min) {
                cur.max = right.max;
                cur.size += right.size;
            } else cur.size = -1;
        }

        if (cur.size > res[0]) res[0] = cur.size;

        return cur;
    }
}
```
### A shorter(not necessarily better) version
```java
import util.TreeNode;

class Solution {
    static class Result {
        int size, min, max;

        Result(int size, int min, int max) {
            this.size = size;
            this.min = min;
            this.max = max;
        }
    }

    public int largestBSTSubtree(TreeNode root) {
        if (root == null) return 0;
        int[] res = new int[1];
        dfs(root, res);
        return res[0];
    }

    private Result dfs(TreeNode root, int[] res) {
        if (root == null) return new Result(0, Integer.MAX_VALUE, Integer.MIN_VALUE);

        Result left = dfs(root.left, res);
        Result right = dfs(root.right, res);

        if (left.size == -1 || root.key <= left.max || right.size == -1 || root.key >= right.min)
            return new Result(-1, 0, 0);

        Result cur = new Result(left.size + right.size + 1, Math.min(left.min, root.key), Math.max(right.max, root.key));

        if (cur.size > res[0]) res[0] = cur.size;

        return cur;
    }
}
```