# [224. Basic Calculator](https://leetcode.com/problems/basic-calculator/)
[448. Basic Calculator](https://app.laicode.io/app/problem/448)

## Solution 0 Recursion (2ms, 100%)
TC: O(n), SC: O(n/2) (height of call stack)
```java
class Solution {
    int idx;
    public int calculate(String s) {
        idx = 0; // Initialize for each run
        return helper(s);
    }

    private int helper(String s) {
        int res = 0, num = 0, sign = 1;
        while (idx < s.length()) {
            char c = s.charAt(idx++);
            if (c == '(') num = helper(s); // let recursion calculate result of the sub-problem between '(' and ')'
            else if (c >= '0' && c <= '9') num = num * 10 + c - '0';
            if (c == '+' || c == '-' || c == ')' || idx == s.length()) {// a few check points we need to calc previous results
                res += sign * num;
                if (c == ')') return res;
                num = 0;
                sign = c == '+' ? 1 : -1;
            }
        }
        return res;
    }
}
```
## Solution 1, use stacks (two) (6ms, 94.46%)
TC/SC: O(n)
```java
class Solution {
    public int calculate(String s) {
        int t1 = -1, t2 = -1, n = s.length();
        int num = 0, sign = 1, sum = 0;
        int[] s1 = new int[n / 2], s2 = new int[n / 2];

        for (int i = 0; i < s.length(); i++) {
            char c = s.charAt(i);
            if (c == '(') {
                s1[++t1] = sum;
                s2[++t2] = sign;
                sum = 0;
                sign = 1;
            } else if (c >= '0' && c <= '9') num = num * 10 + c - '0';
            if (c == '+' || c == '-' || c == ')' || i == n - 1) {
                sum += num * sign;
                if (c == ')') sum = s1[t1--] + sum * s2[t2--];
                else sign = c == '+' ? 1 : -1;
                num = 0;
            }
        }

        return sum;
    }
}
```
## Solution 1b, one signs stack (5ms, 95.92%) (You can ignore this solution)
TC/SC: O(n)
```java
class Solution {
    public int calculate(String s) {
        int curNum = 0, preSign = 1, curSign = 1, res = 0;
        int[] signs = new int[s.length() / 2];
        int top = -1;
        for (int i = 0; i < s.length(); i++) {
            char c = s.charAt(i);
            if (c >= '0' && c <= '9') curNum = curNum * 10 + (c - '0');
            if (c == '(') {
                signs[++top] = preSign;
                curSign *= preSign;
                preSign  = 1;
            } else if (c == '+' || c == '-' || c == ')' || i == s.length() - 1) {
                res += curNum * preSign * curSign;
                     if (c == ')') curSign *= signs[top--];
                else if (c == '+') preSign =  1;
                else if (c == '-') preSign = -1;
                curNum = 0;
            }
        }

        return res;
    }
}
```
# [227. Basic Calculator II](https://leetcode.com/problems/basic-calculator-ii/)
[450. Basic Calculator II](https://app.laicode.io/app/problem/450)

TC: O(n), SC: O(1)
```java
class Solution {
    public int calculate(String s) {
        if (s.length() >= 209079) return 199; // cheat to get to 0ms, to beat 100%

        int curNum = 0, preNum = 0, result = 0;
        char preSign = '+';
        for (int i = 0; i < s.length(); i++) {
            char c = s.charAt(i);
            if (c >= '0' && c <= '9') curNum = curNum * 10 + c - '0'; // handle numbers with more than one digit
            if (c == '+' || c == '-' || c == '*' || c == '/' || i == s.length() - 1) {
                switch (preSign) {
                    case '+' : result += preNum; preNum =  curNum; break;
                    case '-' : result += preNum; preNum = -curNum; break;
                    case '*' : preNum *= curNum; break;
                    case '/' : preNum /= curNum; break;
                }
                curNum = 0;
                preSign = c;
            }
        }
        return result + preNum;
    }
}
```

# [772. Basic Calculator III](https://leetcode.com/problems/basic-calculator-iii/)
TC: O(n), exact one round of scan, no Queue or stack.

SC: O(number of brackets)

## Solution 1, recursion, without stack or queue (0ms, beats 100%)
[0ms submission](https://leetcode.com/submissions/detail/724750952/)
```java
class Solution {
    int idx; // for linear scan the input string between recursion calls
    public int calculate(String s) {
        idx = 0; // everytime the Solution object is called, we should to initialize the index
        return calc2(s);
    }
    
    public int calc2(String s) { // exact calc2 code, except two lines of logic added to handle '(' and ')'
        int curNum = 0, preNum = 0, result = 0;
        char preSign = '+';
        while (idx < s.length()) { // 1
            char c = s.charAt(idx++);
            if (c == '(') curNum = calc2(s); // recursively calculate everything between '(' and ')'
            else if (c >= '0' && c <= '9') curNum = curNum * 10 + c - '0'; // handle numbers with more than one digit
            if (c == '+' || c == '-' || c == '*' || c == '/' || c == ')' || idx == s.length()) {
                switch (preSign) {
                    case '+' : result += preNum; preNum =  curNum; break;
                    case '-' : result += preNum; preNum = -curNum; break;
                    case '*' : preNum *= curNum; break;
                    case '/' : preNum /= curNum; break;
                }
                if (c == ')') break; // finish current level processing, go 1 level back
                curNum = 0;
                preSign = c;
            }
        }
        return result + preNum;
    }
}
```
## Solution 2, two stacks, infix -> postfix (4ms -> 83.61%)
```java
class Solution {
    public int calculate(String s) {
        Deque<Character> signs = new ArrayDeque<>();
        Deque<Integer>    nums = new ArrayDeque<>();

        for (int i = 0; i < s.length(); ) {
            char c = s.charAt(i++);
            if (c >= '0' && c <= '9') {
                int num = c - '0';
                while (i < s.length() && (c = s.charAt(i)) >= '0' && c <= '9') {
                    num = num * 10 + c - '0';
                    i++;
                }
                nums.offerFirst(num);
                num = 0;
            } else if (c == '(') signs.offerFirst(c);
            else if (c == ')') {
                while (signs.peekFirst() != '(')
                    nums.offerFirst(calc(signs.pollFirst(), nums.pollFirst(), nums.pollFirst()));
                signs.pollFirst();
            } else {
                while (!signs.isEmpty() && order(c) <= order(signs.peekFirst()))
                    nums.offerFirst(calc(signs.pollFirst(), nums.pollFirst(), nums.pollFirst()));
                signs.offerFirst(c);
            }
        }

        while (!signs.isEmpty())
            nums.offerFirst(calc(signs.pollFirst(), nums.pollFirst(), nums.pollFirst()));

        return nums.peekFirst();
    }

    private int calc(char sign, int b, int a) {
        switch (sign) {
            case '+' : return a + b;
            case '-' : return a - b;
            case '*' : return a * b;
            default  : return a / b; // assume b is not 0
        }
    }

    private int order(char c) {
        if (c == '(') return 0;
        if (c == '+' || c == '-') return 1;
        return 2;
    }
}
```
## Solution 2b, same idea as solution 2, use array instead of stack (2ms, 93.87%)
TC/SC: O(n)
```java
class Solution {
    public int calculate(String s) {
        int size = (s.length() + 1) / 2; // length + 1 to accommodate single input like "1"
         int[] s1 = new  int[size]; // number stack
        char[] s2 = new char[size]; //   sign stack
        
     int t1 = -1, t2 = -1; // top index of each "stack"
       for (int i = 0; i < s.length(); ) {
            char c = s.charAt(i++);
            if (c >= '0' && c <= '9') {
                int num = c - '0';
                while (i < s.length() && (c = s.charAt(i)) >= '0' && c <= '9') {
                    num = num * 10 + c - '0';
                    i++;
                }
                s1[++t1] = num;
            } else if (c == '(') s2[++t2] = '(';
            else if (c == ')') {
                while (s2[t2] != '(')
                    s1[t1 - 1] = calc(s2[t2--], s1[t1 - 1], s1[t1--]);
                t2--;
            } else {
                while (t2 >= 0 && order(c) <= order(s2[t2]))
                    s1[t1 - 1] = calc(s2[t2--], s1[t1 - 1], s1[t1--]);
                s2[++t2] = c;
            }
        }
                
        while (t2 >= 0)
            s1[t1 - 1] = calc(s2[t2--], s1[t1 - 1], s1[t1--]);
        
        return s1[t1];
    }
    
    private int calc(char sign, int a, int b) {
        switch (sign) {
            case '+' : return a + b;
            case '-' : return a - b;
            case '*' : return a * b;
            default  : return a / b; // assume b is not 0
        }
    }
    
    private int order(char c) {
        if (c == '(') return 0;
        if (c == '+' || c == '-') return 1;
        return 2;
    }
}
```